/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package imrcp.collect;

import imrcp.geosrv.GeoUtil;
import imrcp.geosrv.Mercator;
import imrcp.geosrv.WayNetworks;
import imrcp.geosrv.osm.OsmWay;
import imrcp.store.Obs;
import imrcp.system.Directory;
import imrcp.system.ExtMapping;
import imrcp.system.FilenameFormatter;
import imrcp.system.Id;
import imrcp.system.JSONUtil;
import imrcp.system.ObsType;
import imrcp.system.ResourceRecord;
import imrcp.system.Scheduling;
import imrcp.system.StringPool;
import imrcp.system.TileForPoint;
import imrcp.system.Units;
import imrcp.system.Units.UnitConv;
import imrcp.system.Util;
import imrcp.system.XzWrapper;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.zip.GZIPOutputStream;
import org.json.JSONArray;
import org.json.JSONObject;
import org.json.JSONTokener;
import imrcp.system.TileFileWriter;
import java.io.BufferedReader;
import java.io.InputStreamReader;

/**
 * Generic collector for Inrix data
 * @author aaron.cherney
 */
public class Inrix extends Collector
{
	/**
	 *  A unique id provided by INRIX representative
	 */
	private String m_sAppId;

	
	/**
	 * The hash token for your app. This is generated by the following sequence.
	 *	1. Create a string with a value of AppId|AppKey â€“ The AppKey is a value provided by INRIX and is separate from the AppId value (also provided for each customer). The string is the AppId joined to the Appkey separated by a | symbol.
	 *	2. Lowercase the string value
	 *	3. Encode the string into a byte array using UTF-8 encoding
	 *	4. Use SHA1 to hash the bytes
	 *	5. Write the resulting bytes in hexadecimal for the hashToken value.
	 */
	private String m_sAppToken;

	
	/**
	 * Stores the current authentication token
	 */
	private String m_sCurrentToken = null;

	
	/**
	 * Format string to generate the url to get an authentication token
	 */
	private String m_sTokenUrl;

	
	/**
	 * List of int[] which represent the map tiles used at the configured zoom level
	 * to create bounding boxes for data queries. Format is [x, y]
	 */
	ArrayList<int[]> m_nTiles = new ArrayList();

	
	/**
	 * Zoom level used for creating bounding boxes for the tiles stored in 
	 * {@link Inrix#m_nTiles}
	 */
	private int m_nZoom;

	
	/**
	 * Configurable array to store key value pairs that can be used to specify
	 * query parameters in the url. [key1, value1, key2, value2, ..., keyn, valuen]
	 */
	private String[] m_sQueryString;

	
	/**
	 * Contains emails that will receive error messages 
	 */
	private String[] m_sEmails;
	
	
	/**
	 *
	 */
	@Override
	public void reset(JSONObject oBlockConfig)
	{
		super.reset(oBlockConfig);
		m_sAppId = oBlockConfig.optString("appid", "");
		m_sAppToken = oBlockConfig.optString("apptoken", "");
		m_sTokenUrl = oBlockConfig.optString("tokenurl", "");
		m_nZoom = oBlockConfig.optInt("zoom", 8);
		int[] nXs = JSONUtil.getIntArray(oBlockConfig, "xs");
		for (int nX : nXs)
		{
			for (int nY : JSONUtil.getIntArray(oBlockConfig, Integer.toString(nX)))
				m_nTiles.add(new int[]{nX, nY});
			
		}
		m_sQueryString = JSONUtil.getStringArray(oBlockConfig, "query");
		m_sEmails = JSONUtil.getStringArray(oBlockConfig, "emails");
	}
	
	
	/**
	 * Checks if {@link Inrix#m_sQueryString} has an even length (throws an 
	 * Exception if the length is odd), calls {@link Inrix#getToken()} and sets 
	 * a schedule to execute on a fixed interval.
	 * @return true if no exceptions are thrown
	 * @throws Exception
	 */
	@Override
	public boolean start()
		throws Exception
	{
		if (m_sQueryString.length % 2 != 0)
			throw new Exception("Invalid query string configuration");
		getToken();
		m_nSchedId = Scheduling.getInstance().createSched(this, m_nOffset, m_nPeriod);
		return true;
	}
	
	
	/**
	 * Queries the Inrix Segment Speed api by generating a URL for each of the 
	 * configured map tiles at the configured zoom level and saves the resulting
	 * JSON objects in a single JSON array on disk
	 */
	@Override
	public void execute()
	{
		try
		{
			long lNow = System.currentTimeMillis() / 60000 * 60000; // floor to nearest minute
			ResourceRecord oRR = Directory.getResource(m_nContribId, m_nObsTypeId);
			long lStart = getStartTime(lNow, oRR.getRange(), oRR.getDelay(), 0);
			long lEnd = getEndTime(lNow, oRR.getRange(), oRR.getDelay(), 0);
			double[] dBounds = new double[4];
			Mercator oM = new Mercator();
			StringBuilder sUrl = new StringBuilder(512);
			ByteArrayOutputStream oSpeeds = new ByteArrayOutputStream(16384000);
			oSpeeds.write('['); // going to concatenate all of the json object responses into a single json array
			synchronized (this)
			{
				sUrl.append(m_sBaseURL).append("?accesstoken=").append(m_sCurrentToken);
			}
			for (int nIndex = 0; nIndex < m_sQueryString.length;)
			{
				sUrl.append('&').append(m_sQueryString[nIndex++]).append('=').append(m_sQueryString[nIndex++]);
			}
			sUrl.append("&box=");
			String sBboxFormat = "%2.7f|%2.7f,%2.7f|%2.7f";
			int nDeleteIndex = sUrl.length();
			for (int nIndex = 0; nIndex < m_nTiles.size(); nIndex++)
			{
				int[] nTile = m_nTiles.get(nIndex);
				oM.lonLatBounds(nTile[0], nTile[1], m_nZoom, dBounds);
				sUrl.delete(nDeleteIndex, sUrl.length());
				sUrl.append(String.format(sBboxFormat, dBounds[3], dBounds[0], dBounds[1], dBounds[2])); // bounds array order = minx, miny, maxx, maxy and query order = northwest corner, southeast corner
				m_oLogger.info(sUrl);
				URL oUrl = new URL(sUrl.toString());
				HttpURLConnection oConn = (HttpURLConnection)oUrl.openConnection();
				oConn.setReadTimeout(60000);
				oConn.setConnectTimeout(60000);
				JSONObject oResult;
				try (BufferedReader oIn = new BufferedReader(new InputStreamReader(oConn.getInputStream())))
				{
					oResult = new JSONObject(new JSONTokener(oIn));
				}
				if (nIndex != m_nTiles.size() - 1)
					oSpeeds.write(',');
			}
			oSpeeds.write(']');
			
			FilenameFormatter oArchiveFF = new FilenameFormatter(oRR.getArchiveFf());
			Path oArchive = Paths.get(oArchiveFF.format(lNow, lStart, lEnd));
			Files.createDirectories(oArchive.getParent());
			byte[] yJson = oSpeeds.toByteArray();
			try (GZIPOutputStream oGzip = Util.getGZIPOutputStream(Files.newOutputStream(oArchive)))
			{
				oGzip.write(yJson); // gzip the byte array
			}
			
			ExtMapping oExtMap = (ExtMapping)Directory.getInstance().lookup("ExtMapping");
			WayNetworks oWays = (WayNetworks)Directory.getInstance().lookup("WayNetworks");
			JSONArray oJson = new JSONArray(new JSONTokener(new BufferedInputStream(new ByteArrayInputStream(yJson))));
			Units oUnits = Units.getInstance();
			FilenameFormatter oFF = new FilenameFormatter(oRR.getTiledFf());
			Path oTiledFile = oRR.getFilename(lNow, lStart, lEnd, oFF);
			Files.createDirectories(oTiledFile.getParent());
			int nPPT = (int)Math.pow(2, oRR.getTileSize()) - 1;
			oM = new Mercator(nPPT);
			ArrayList<TileForPoint> oTiles = new ArrayList();
			StringPool oSP = new StringPool();
			int[] nTile = new int[2];
			int[] nBB = new int[]{Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE};
			for (int nObjIndex = 0 ;nObjIndex < oJson.length(); nObjIndex++)
			{
				JSONObject oInrixTile = oJson.getJSONObject(nObjIndex);
				JSONObject oResult = oInrixTile.getJSONObject("result");
				String sUnit = oResult.getString("unit").toLowerCase();
				UnitConv oConv = oUnits.getConversion(sUnit, ObsType.getUnits(m_nObsTypeId, true));
				JSONArray oSegmentSpeeds = oResult.getJSONArray("segmentspeeds");
				for (int nSegmentIndex = 0; nSegmentIndex < oSegmentSpeeds.length(); nSegmentIndex++)
				{
					JSONArray oSegments = oSegmentSpeeds.getJSONObject(nSegmentIndex).getJSONArray("segments");
					for (int nSpeedIndex = 0; nSpeedIndex < oSegments.length(); nSpeedIndex++)
					{
						JSONObject oSpeedRec = oSegments.getJSONObject(nSpeedIndex);
						String sCode = oSpeedRec.optString("code");
						double dSpeed = oSpeedRec.optDouble("speed", Double.NaN);
						if (sCode == null || Double.isNaN(dSpeed))
							continue;
						Id[] oIds = oExtMap.getMapping(m_nContribId, sCode);
						if (oIds == null) // ignore observations that cannot be mapped to an IMRCP roadway segment
						{
							continue;
						}
						for (Id oId : oIds)
						{
							OsmWay oWay = oWays.getWayById(oId);
							if (oWay == null)
								continue;
							Obs oObs = new Obs();
							oObs.m_sStrings = new String[]{sCode, null, null, null, null, null, null, null};
							oObs.m_dValue = TileFileWriter.nearest(oConv.convert(dSpeed), oRR.getRound());
							oObs.m_oGeo = Obs.createPoint(oWay.m_nMidLon, oWay.m_nMidLat);
							for (int nString = 0; nString < m_nStrings; nString++)
								oSP.intern(oObs.m_sStrings[nString]);
							int nLon = oWay.m_nMidLon;
							int nLat = oWay.m_nMidLat;
							if (nLon < nBB[0])
								nBB[0] = nLon;
							if (nLat < nBB[1])
								nBB[1] = nLat;
							if (nLon > nBB[2])
								nBB[2] = nLon;
							if (nLat > nBB[3])
								nBB[3] = nLat;
							oM.lonLatToTile(GeoUtil.fromIntDeg(nLon), GeoUtil.fromIntDeg(nLat), oRR.getZoom(), nTile);
							TileForPoint oTile = new TileForPoint(nTile[0], nTile[1]);
							int nIndex = Collections.binarySearch(oTiles, oTile);
							if (nIndex < 0)
							{
								nIndex = ~nIndex;
								oTiles.add(nIndex, oTile);
							}

							oTiles.get(nIndex).add(oObs);
						}
					}
				}
			}
				
			m_oLogger.info(oTiles.size());
			ArrayList<String> oSPList = oSP.toList();
			if (oSPList.isEmpty())
				oSPList = null;
			ThreadPoolExecutor oTP = (ThreadPoolExecutor)Executors.newFixedThreadPool(m_nThreads);
			Future oFirstTask = null;
			int nStringFlag = 0;
			for (int nString = 0; nString < m_nStrings; nString++)
				nStringFlag = Obs.addFlag(nStringFlag, nString);
			for (TileForPoint oTile : oTiles)
			{
				oTile.m_oSP = oSPList;
				oTile.m_oM = oM;
				oTile.m_oRR = oRR;
				oTile.m_lTimestamp = lNow;
				oTile.m_nStringFlag = nStringFlag;
				oTile.m_bWriteObsFlag = false;
				oTile.m_bWriteRecv = false;
				oTile.m_bWriteStart = false;
				oTile.m_bWriteEnd = false;
				oTile.m_bWriteObsType = false;
				oTile.setValueWriter(oRR.getValueType());
				Future oTask = oTP.submit(oTile);
				if (oTask != null && oFirstTask == null)
					oFirstTask = oTask;
			}

			if (oFirstTask != null)
				oFirstTask.get();
			oTP.shutdown();
			oTP.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
			try (DataOutputStream oOut = new DataOutputStream(new BufferedOutputStream(Files.newOutputStream(oTiledFile))))
			{
				oOut.writeByte(1); // version
				oOut.writeInt(nBB[0]); // bounds min x
				oOut.writeInt(nBB[1]); // bounds min y
				oOut.writeInt(nBB[2]); // bounds max x
				oOut.writeInt(nBB[3]); // bounds max y
				oOut.writeInt(oRR.getObsTypeId()); // obsversation type
				oOut.writeByte(Util.combineNybbles(0, oRR.getValueType())); // obs flag not present on obs = 0 (upper nybble) value type unsigned byte =  (lower nybble)
				oOut.writeByte(Obs.POINT);
				oOut.writeByte(0); // id format: -1=variable, 0=null, 16=uuid, 32=32-bytes
				oOut.writeByte(Util.combineNybbles(Id.SEGMENT, 0)); // associate with obj and timestamp flag
				oOut.writeLong(lNow);
				oOut.writeInt((int)((lEnd - lNow) / 1000)); // end time offset from received time
				oOut.writeByte(1); // only file start time
				oOut.writeInt((int)((lStart - lNow) / 1000));
				if (oSPList == null)
					oOut.writeInt(0);
				else
				{
					ByteArrayOutputStream oRawBytes = new ByteArrayOutputStream(8192);
					DataOutputStream oRawOut = new DataOutputStream(oRawBytes);
					for (String sStr : oSPList)
					{
						oRawOut.writeUTF(sStr);
					}
					oRawOut.flush();

					byte[] yCompressed = new XzWrapper().compress(oRawBytes.toByteArray());
					oOut.writeInt(yCompressed.length);  // compressed string pool length
					oOut.writeInt(oSPList.size());
					oOut.write(yCompressed);
				}

				oOut.writeByte(oRR.getZoom()); // tile zoom level
				oOut.writeByte(oRR.getTileSize());
				oOut.writeInt(oTiles.size());
				for (TileForPoint oTile : oTiles) // finish writing tile metadata
				{
					oOut.writeShort(oTile.m_nX);
					oOut.writeShort(oTile.m_nY);
					oOut.writeInt(oTile.m_yData.length);
				}

				for (TileForPoint oTile : oTiles)
				{
					oOut.write(oTile.m_yData);
				}
			}
		}
		catch (Exception oEx)
		{
			m_oLogger.error(oEx, oEx);
		}
	}
	
	
	/**
	 * Queries for and stores in memory a security token from the Inrix api that
	 * is used for authenticating data queries. The response also tells when the
	 * token will expire so {@link imrcp.system.Scheduling} schedules this 
	 * function to run 5 minutes before the token expires.
	 */
	public void getToken()
	{
		StringBuilder sBuf = new StringBuilder(1024);
		try
		{
			URL oUrl = new URL(String.format(m_sTokenUrl, m_sAppId, m_sAppToken));
			HttpURLConnection oConn = (HttpURLConnection)oUrl.openConnection();
			oConn.setReadTimeout(60000);
			oConn.setConnectTimeout(60000);
			oConn.setRequestProperty("Accept", "application/xml");
			StringBuilder sValBuf = new StringBuilder(340);
			try (BufferedInputStream oIn = new BufferedInputStream(oConn.getInputStream()))
			{
				int nByte;
				while ((nByte = oIn.read()) >= 0)
					sBuf.append((char)nByte);
			}
			
			SimpleDateFormat oSdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssX");
			int nStart = sBuf.indexOf("<Expiry");
			nStart = sBuf.indexOf(">", nStart) + 1;
			sValBuf.append(sBuf.subSequence(nStart, sBuf.indexOf("</Expiry>")));
			nStart = sValBuf.indexOf(".");
			sValBuf.delete(nStart, nStart + 8); // remove 10e-7 seconds
			
			nStart = sBuf.indexOf("<Token");
			nStart = sBuf.indexOf(">", nStart) + 1;
			synchronized (this)
			{
				m_sCurrentToken = sBuf.substring(nStart, sBuf.indexOf("</Token>"));
			}
			Date oExpires;
			try
			{
				oExpires = oSdf.parse(sValBuf.toString());
			}
			catch (ParseException oParseEx)
			{
				oSdf.applyPattern("yyyy-MM-dd'T'HH:mm:ss");
				oExpires = oSdf.parse(sValBuf.toString());
			}
			oExpires.setTime(oExpires.getTime() - 300000); // get a new token 5 minutes before the old one expires
			Scheduling.getInstance().scheduleOnce(() -> getToken(), oExpires); 
		}
		catch (Exception oEx)
		{
			try
			{	
				m_oLogger.error(oEx, oEx);
				setError();
			}
			catch (Exception oEmailEx)
			{
				m_oLogger.error(oEmailEx, oEmailEx);
			}
		}
	}
}
