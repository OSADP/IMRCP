package imrcp.geosrv;

import imrcp.system.JSONUtil;
import imrcp.system.Units;
import org.json.JSONObject;

/**
 * Class used to bucket ranges of values of a specific observation type to a 
 * single value to aid in presentation and grouping similar observations.
 * @author aaron.cherney
 */
public class RangeRules implements Comparable<RangeRules>
{
	/**
	 * Double value that corresponds to an invalid numerical value
	 */
	public double m_dNaNMapping;

	
	/**
	 * Array that stores the ranges in pairs [min1, max1, min2, max2,... minn, maxn]
	 */
	public double[] m_dRanges;

	
	/**
	 * Array that stores the ranges that should be ignored or deleted in pairs
	 * [min1, max1, min2, max2,... minn, maxn]
	 */
	public double[] m_dDeleteRanges;
	
	
	/**
	 * IMRCP observation type the rules are valid for.
	 */
	public int m_nObsType;
	
	public String m_sUnits;

	
	public RangeRules()
	{
	}
	
	
	/**
	 * Wrapper for {@link #RangeRules(int)}. It converts the given observation 
	 * type to its integer representation.
	 * @param sObsType up to 6 alphanumeric characters representing an observation
	 * type
	 */
	public RangeRules(int nObsType, String sUnits)
	{
		m_nObsType = nObsType;
		m_sUnits = sUnits;
	}
	
	
	/**
	 * Constructs a RangeRules object for the given observation type by reading
	 * values from the Configuration component.
	 * @param nObsType IMRCP observation type
	 */
	public RangeRules(JSONObject oConfig, int nObsType)
	{
		m_nObsType = nObsType;
		
		m_dNaNMapping = Double.parseDouble(oConfig.optString("nan", "-9999"));
		String[] sRanges = JSONUtil.getStringArray(oConfig, "ranges");
		String[] sDelete = JSONUtil.getStringArray(oConfig, "delete");
		
		m_dRanges = new double[sRanges.length];
		for (int i = 0; i < sRanges.length; i++)
			m_dRanges[i] = Double.parseDouble(sRanges[i]);

		m_dDeleteRanges = new double[sDelete.length];
		for (int i = 0; i < sDelete.length; i++)
			m_dDeleteRanges[i] = Double.parseDouble(sDelete[i]);
		
		m_sUnits = oConfig.optString("units", "");
	}
	
	
	public RangeRules(RangeRules oOriginal, String sConvertTo)
	{
		Units oUnits = Units.getInstance();
		m_nObsType = oOriginal.m_nObsType;
		m_sUnits = sConvertTo;
		m_dDeleteRanges = new double[oOriginal.m_dDeleteRanges.length];
		for (int nIndex = 0; nIndex < m_dDeleteRanges.length; nIndex++)
		{
			double dVal = oOriginal.m_dDeleteRanges[nIndex];
			if (Double.isFinite(dVal))
				m_dDeleteRanges[nIndex] = oUnits.convert(oOriginal.m_sUnits, sConvertTo, dVal);
			else
				m_dDeleteRanges[nIndex] = dVal;
		}

		m_dRanges = new double[oOriginal.m_dRanges.length];
		for (int nIndex = 0; nIndex < m_dRanges.length; nIndex++)
		{
			double dVal = oOriginal.m_dRanges[nIndex];
			if (Double.isFinite(dVal))
				m_dRanges[nIndex] = oUnits.convert(oOriginal.m_sUnits, sConvertTo, dVal);
			else
				m_dRanges[nIndex] = dVal;
		}

		m_dNaNMapping = oOriginal.m_dNaNMapping;
	}

	
	/**
	 * Determines if the given group value should be deleted/ignored based on the
	 * configured ranges.
	 * @param dGroupVal group value generated by {@link #groupValue(double)}
	 * @return true if the value if equal to the nan mapping, is {@code Double.NaN},
	 * or within one of the delete ranges, otherwise false.
	 */
	public boolean shouldDelete(double dGroupVal)
	{
		if (dGroupVal == m_dNaNMapping || Double.isNaN(dGroupVal)) // check for NaN
			return true;
		for (int i = 0; i < m_dDeleteRanges.length; i += 2) // check each range
		{
			if (dGroupVal >= m_dDeleteRanges[i] && dGroupVal < m_dDeleteRanges[i + 1])
				return true;
		}
		return false;
	}

	
	/**
	 * Gets the group/bucket value for the given value.
	 * @param dVal value to group
	 * @return The lower value of the range/group the value falls in or the nan
	 * mapping if the given value is {@code Double.NaN} or not within one of the
	 * configured ranges.
	 */
	public double groupValue(double dVal)
	{
		if (Double.isNaN(dVal))
			return m_dNaNMapping;
		for (int i = 0; i < m_dRanges.length; i += 2)
		{
			if (dVal >= m_dRanges[i] && dVal < m_dRanges[i + 1])
				return m_dRanges[i];
		}
		return m_dNaNMapping;
	}

	@Override
	public int compareTo(RangeRules o)
	{
		int nRet = m_nObsType - o.m_nObsType;
		if (nRet == 0)
			nRet = m_sUnits.compareTo(o.m_sUnits);
		
		return nRet;
	}
}
