/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package imrcp.collect;

import imrcp.geosrv.Mercator;
import imrcp.system.Email;
import imrcp.system.Emails;
import imrcp.system.Scheduling;
import imrcp.system.Util;
import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.zip.GZIPOutputStream;

/**
 * Generic collector for Inrix data
 * @author Federal Highway Administration
 */
public class Inrix extends Collector
{
	/**
	 *  A unique id provided by INRIX representative
	 */
	private String m_sAppId;

	
	/**
	 * The hash token for your app. This is generated by the following sequence.
	 *	1. Create a string with a value of AppId|AppKey â€“ The AppKey is a value provided by INRIX and is separate from the AppId value (also provided for each customer). The string is the AppId joined to the Appkey separated by a | symbol.
	 *	2. Lowercase the string value
	 *	3. Encode the string into a byte array using UTF-8 encoding
	 *	4. Use SHA1 to hash the bytes
	 *	5. Write the resulting bytes in hexadecimal for the hashToken value.
	 */
	private String m_sAppToken;

	
	/**
	 * Stores the current authentication token
	 */
	private String m_sCurrentToken = null;

	
	/**
	 * Format string to generate the url to get an authentication token
	 */
	private String m_sTokenUrl;

	
	/**
	 * List of int[] which represent the map tiles used at the configured zoom level
	 * to create bounding boxes for data queries. Format is [x, y]
	 */
	ArrayList<int[]> m_nTiles = new ArrayList();

	
	/**
	 * Zoom level used for creating bounding boxes for the tiles stored in 
	 * {@link Inrix#m_nTiles}
	 */
	private int m_nZoom;

	
	/**
	 * Configurable array to store key value pairs that can be used to specify
	 * query parameters in the url. [key1, value1, key2, value2, ..., keyn, valuen]
	 */
	private String[] m_sQueryString;

	
	/**
	 * Contains emails that will receive error messages 
	 */
	private String[] m_sEmails;
	
	
	/**
	 *
	 */
	@Override
	public void reset()
	{
		super.reset();
		m_sAppId = m_oConfig.getString("appid", "");
		m_sAppToken = m_oConfig.getString("apptoken", "");
		m_sTokenUrl = m_oConfig.getString("tokenurl", "");
		m_nZoom = m_oConfig.getInt("zoom", 8);
		String[] sXs = m_oConfig.getStringArray("xs", "");
		for (String sX : sXs)
		{
			int nX = Integer.parseInt(sX);
			for (int nY : m_oConfig.getIntArray(sX, Integer.MIN_VALUE))
				m_nTiles.add(new int[]{nX, nY});
			
		}
		m_sQueryString = m_oConfig.getStringArray("query", null);
		m_sEmails = m_oConfig.getStringArray("emails", null);
	}
	
	
	/**
	 * Checks if {@link Inrix#m_sQueryString} has an even length (throws an 
	 * Exception if the length is odd), calls {@link Inrix#getToken()} and sets 
	 * a schedule to execute on a fixed interval.
	 * @return true if no exceptions are thrown
	 * @throws Exception
	 */
	@Override
	public boolean start()
		throws Exception
	{
		if (m_sQueryString.length % 2 != 0)
			throw new Exception("Invalid query string configuration");
		getToken();
		m_nSchedId = Scheduling.getInstance().createSched(this, m_nOffset, m_nPeriod);
		return true;
	}
	
	
	/**
	 * Queries the Inrix Segment Speed api by generating a URL for each of the 
	 * configured map tiles at the configured zoom level and saves the resulting
	 * JSON objects in a single JSON array on disk
	 */
	@Override
	public void execute()
	{
		try
		{
			long lNow = System.currentTimeMillis() / 60000 * 60000; // floor to nearest minute
			
			double[] dBounds = new double[4];
			Mercator oM = new Mercator();
			StringBuilder sUrl = new StringBuilder(512);
			ByteArrayOutputStream oSpeeds = new ByteArrayOutputStream(16384000);
			oSpeeds.write('['); // going to concatenate all of the json object responses into a single json array
			synchronized (this)
			{
				sUrl.append(m_sBaseURL).append("?accesstoken=").append(m_sCurrentToken);
			}
			for (int nIndex = 0; nIndex < m_sQueryString.length;)
			{
				sUrl.append('&').append(m_sQueryString[nIndex++]).append('=').append(m_sQueryString[nIndex++]);
			}
			sUrl.append("&box=");
			String sBboxFormat = "%2.7f|%2.7f,%2.7f|%2.7f";
			int nDeleteIndex = sUrl.length();
			for (int nIndex = 0; nIndex < m_nTiles.size(); nIndex++)
			{
				int[] nTile = m_nTiles.get(nIndex);
				oM.lonLatBounds(nTile[0], nTile[1], m_nZoom, dBounds);
				sUrl.delete(nDeleteIndex, sUrl.length());
				sUrl.append(String.format(sBboxFormat, dBounds[3], dBounds[0], dBounds[1], dBounds[2])); // bounds array order = minx, miny, maxx, maxy and query order = northwest corner, southeast corner
				m_oLogger.info(sUrl);
				URL oUrl = new URL(sUrl.toString());
				HttpURLConnection oConn = (HttpURLConnection)oUrl.openConnection();
				oConn.setReadTimeout(60000);
				oConn.setConnectTimeout(60000);
				try (BufferedInputStream oIn = new BufferedInputStream(oConn.getInputStream()))
				{
					int nByte;
					while ((nByte = oIn.read()) >= 0)
						oSpeeds.write(nByte);
				}
				if (nIndex != m_nTiles.size() - 1)
					oSpeeds.write(',');
			}
			oSpeeds.write(']');
			String sDest = m_oDestFile.format(lNow, lNow, lNow + m_nRange);
			Path oPath = Paths.get(sDest);
			Files.createDirectories(oPath.getParent());
			try (GZIPOutputStream oGzip = Util.getGZIPOutputStream(Files.newOutputStream(oPath)))
			{
				oGzip.write(oSpeeds.toByteArray()); // gzip the byte array
				oGzip.flush();
			}
			notify("file download", sDest);
		}
		catch (Exception oEx)
		{
			m_oLogger.error(oEx, oEx);
		}
	}
	
	
	/**
	 * Queries for and stores in memory a security token from the Inrix api that
	 * is used for authenticating data queries. The response also tells when the
	 * token will expire so {@link imrcp.system.Scheduling} schedules this 
	 * function to run 5 minutes before the token expires.
	 */
	public void getToken()
	{
		StringBuilder sBuf = new StringBuilder(1024);
		try
		{
			URL oUrl = new URL(String.format(m_sTokenUrl, m_sAppId, m_sAppToken));
			HttpURLConnection oConn = (HttpURLConnection)oUrl.openConnection();
			oConn.setReadTimeout(60000);
			oConn.setConnectTimeout(60000);
			oConn.setRequestProperty("Accept", "application/xml");
			StringBuilder sValBuf = new StringBuilder(340);
			try (BufferedInputStream oIn = new BufferedInputStream(oConn.getInputStream()))
			{
				int nByte;
				while ((nByte = oIn.read()) >= 0)
					sBuf.append((char)nByte);
			}
			
			SimpleDateFormat oSdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssX");
			int nStart = sBuf.indexOf("<Expiry");
			nStart = sBuf.indexOf(">", nStart) + 1;
			sValBuf.append(sBuf.subSequence(nStart, sBuf.indexOf("</Expiry>")));
			nStart = sValBuf.indexOf(".");
			sValBuf.delete(nStart, nStart + 8); // remove 10e-7 seconds
			
			nStart = sBuf.indexOf("<Token");
			nStart = sBuf.indexOf(">", nStart) + 1;
			synchronized (this)
			{
				m_sCurrentToken = sBuf.substring(nStart, sBuf.indexOf("</Token>"));
			}
			Date oExpires;
			try
			{
				oExpires = oSdf.parse(sValBuf.toString());
			}
			catch (ParseException oParseEx)
			{
				oSdf.applyPattern("yyyy-MM-dd'T'HH:mm:ss");
				oExpires = oSdf.parse(sValBuf.toString());
			}
			oExpires.setTime(oExpires.getTime() - 300000); // get a new token 5 minutes before the old one expires
			Scheduling.getInstance().scheduleOnce(() -> getToken(), oExpires); 
		}
		catch (Exception oEx)
		{
			try
			{	
				m_oLogger.error(oEx, oEx);
				setError();
				Emails.send(new Email(m_sEmails, "Inrix Token Failed", String.format("Failed to get Inrix Token at %s for %s.\n\n%s", new SimpleDateFormat("yyyy/MM/dd").format(System.currentTimeMillis()), getName(), sBuf.toString())));
			}
			catch (Exception oEmailEx)
			{
				m_oLogger.error(oEmailEx, oEmailEx);
			}
		}
	}
}
