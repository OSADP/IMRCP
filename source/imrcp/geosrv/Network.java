/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package imrcp.geosrv;

import imrcp.geosrv.osm.OsmNode;
import imrcp.geosrv.osm.OsmWay;
import imrcp.store.Obs;
import imrcp.system.Arrays;
import imrcp.system.Id;
import imrcp.system.Introsort;
import java.awt.geom.Area;
import java.awt.geom.Path2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import org.json.JSONArray;
import org.json.JSONObject;
import qh.Point;
import qh.QuickHullAlgorithm;

/**
 * This class represents the roadway networks used by the system. They are 
 * created by using the web UI that interface with {@link imrcp.web.NetworkGeneration}.
 * @author Federal Highway Administration
 */
public class Network implements Comparable<Network>
{
	/**
	 * Bounding polygon of the network
	 */
	private int[] m_nGeometry;

	
	/**
	 * User given label of the network
	 */
	public String m_sLabel;

	
	/**
	 * Flag indicting the status of loading and processing the segments.
	 * 0 - finished loading all segments
	 * 1 - in the process of loading segments
	 * 2 - an error occurred when loading segments
	 */
	public int m_nLoaded;

	
	/**
	 * Flag indicting if the network has been finalized or not
	 */
	public boolean m_bFinalized;

	
	/**
	 * A Base64 encoded String of a 16 byte id generated by the coordinates
	 * of the geometry of the network.
	 */
	public String m_sNetworkId;

	
	/**
	 * Road classification filters used to create the network. Valid values come
	 * from the highway tag of OSM definitions, including: motorway, motorway_link,
	 * trunk, trunk_link, primary, primary_link, secondary, secondary_link,
	 * tertiary, tertiary_link, residential, unclassified
	 */
	public String[] m_sFilter;

	
	/**
	 * Road options used to create the network. Valid values are motorway, 
	 * connector, trunk, ramp, primary, primary_link, secondary, secondary_link,
	 * tertiary, and tertiary_link
	 */
	public String[] m_sOptions;

	
	/**
	 * List of the roadway segment Ids included in the network
	 */
	public ArrayList<Id> m_oSegmentIds;

	
	/**
	 * The United States the bounding polygon intersects. This is needed because
	 * the system downloads OSM definitions by state.
	 */
	public String[] m_sStates;

	
	/**
	 * Area object used for intersection algorithms
	 */
	private Area m_oArea;
	
	
	/**
	 * Default constructor. Does nothing.
	 */
	Network()
	{
	}
	
	
	/**
	 * Construct a Network with the given parameters. This constructor is used
	 * when the Network is first defined.
	 * 
	 * @param sId Base64 encoded 16 byte id
	 * @param sLabel Network label
	 * @param sOptions options used to create the network
	 * @param nGeo array defining the geometry of the closed bounding polygon. 
	 * It is a growable array from {@link imrcp.system.Arrays} in the format 
	 * [insertion index(size), min lon, min lat, max lon, max lat, lon0, lat0,
	 * lon1, lat1, ... lonn, latn, lon0, lat0]
	 */
	Network(String sId, String sLabel, String[] sOptions, int[] nGeo)
	{
		m_sFilter = m_sStates = new String[0]; // these will get set later
		m_oSegmentIds = new ArrayList();
		m_sNetworkId = sId;
		m_sLabel = sLabel;
		m_bFinalized = false;
		m_nLoaded = 1; // network is still processing
		m_sOptions = sOptions;
		m_nGeometry = nGeo;
		
		setArea();
	}
	
	
	/**
	 * Constructs a Network from a JSONObject created from the Networks JSON
	 * file and the list of Ways and Nodes contained in the Network
	 * @param oFeature JSON representation of the Network
	 * @param oWays a list of the roadway segments in the Network
	 * @param oNodes a list of the nodes that make up all of the roadway segments
	 * int the Network
	 */
	public Network(JSONObject oFeature, ArrayList<OsmWay> oWays, ArrayList<OsmNode> oNodes)
	{
		JSONObject oProps = oFeature.getJSONObject("properties");
		m_sLabel = oProps.getString("label");
		m_nLoaded = oProps.getInt("loaded");
		m_bFinalized = oProps.getBoolean("finalized");
		m_sNetworkId = oProps.getString("networkid");
		JSONArray oFilter = oProps.optJSONArray("filter");
		if (oFilter != null)
		{
			m_sFilter = new String[oFilter.length()];
			for (int nIndex = 0; nIndex < m_sFilter.length; nIndex++)
				m_sFilter[nIndex] = oFilter.getString(nIndex);
		}
		else
			m_sFilter = new String[0];
		
		JSONArray oOptions = oProps.optJSONArray("options");
		if (oOptions != null)
		{
			m_sOptions = new String[oOptions.length()];
			for (int nIndex = 0; nIndex < m_sOptions.length; nIndex++)
				m_sOptions[nIndex] = oOptions.getString(nIndex);
		}
		else
			m_sOptions = new String[0];
		
		JSONArray oStates = oProps.optJSONArray("states");
		if (oStates != null)
		{
			m_sStates = new String[oStates.length()];
			for (int nIndex = 0; nIndex < m_sStates.length; nIndex++)
				m_sStates[nIndex] = oStates.getString(nIndex);
		}
		else
			m_sStates = new String[0];
		
		m_oSegmentIds = new ArrayList(oWays.size());
		for (OsmWay oWay : oWays)
			m_oSegmentIds.add(oWay.m_oId);
		
		Introsort.usort(m_oSegmentIds, Id.COMPARATOR);
		
		if (oNodes == null) // the nodes are not defined so get the geometry from the coordinates array
		{
			JSONArray oCoords = oFeature.getJSONObject("geometry").getJSONArray("coordinates").getJSONArray(0);
			int[] nGeoWBb = Arrays.newIntArray(oCoords.length() + 4);
			nGeoWBb = Arrays.add(nGeoWBb, new int[]{Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE});
			for (int nIndex = 0; nIndex < oCoords.length(); nIndex++)
			{
				JSONArray oPt = oCoords.getJSONArray(nIndex);
				int nLon = GeoUtil.toIntDeg(oPt.getDouble(0));
				int nLat = GeoUtil.toIntDeg(oPt.getDouble(1));

				nGeoWBb = Arrays.add(nGeoWBb, nLon, nLat);
				if (nLon < nGeoWBb[1])
					nGeoWBb[1] = nLon;
				if (nLat < nGeoWBb[2])
					nGeoWBb[2] = nLat;
				if (nLon > nGeoWBb[3])
					nGeoWBb[3] = nLon;
				if (nLat > nGeoWBb[4])
					nGeoWBb[4] = nLat;
			}
			m_nGeometry = nGeoWBb;
		}
		else // use the nodes to calculate the convex hull
		{
			ArrayList<Point> oPoints = new ArrayList();
			for (OsmNode oNode : oNodes)
				oPoints.add(new Point(oNode.m_nLon, oNode.m_nLat));
			QuickHullAlgorithm oQh = new QuickHullAlgorithm(oPoints);

			Comparator<Point> oComp = (Point o1, Point o2) -> 
			{
				int nRet = Double.compare(o1.getX(), o2.getX());
				if (nRet == 0)
					nRet = Double.compare(o1.getY(), o1.getY());
				
				return nRet;
			};
			ArrayList<Point> oHull = oQh.getHullPoints();
			if (oComp.compare(oHull.get(0), oHull.get(oHull.size() - 1)) != 0)
				oHull.add(oHull.get(0));
			int[] nGeoWBb = Arrays.newIntArray(oHull.size() + 6);
			nGeoWBb = Arrays.add(nGeoWBb, new int[]{Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE});
			for (Point oPt : oHull)
			{
				int nLon = (int)oPt.getX();
				int nLat = (int)oPt.getY();

				nGeoWBb = Arrays.add(nGeoWBb, nLon, nLat);
				if (nLon < nGeoWBb[1])
					nGeoWBb[1] = nLon;
				if (nLat < nGeoWBb[2])
					nGeoWBb[2] = nLat;
				if (nLon > nGeoWBb[3])
					nGeoWBb[3] = nLon;
				if (nLat > nGeoWBb[4])
					nGeoWBb[4] = nLat;
			}
			
			m_nGeometry = nGeoWBb;
		}
		
		setArea();
	}
	
	
	/**
	 * Creates a new GeoJson Feature object representation of the Network
	 * 
	 * @return GeoJson Feature object representing the Network
	 */
	public JSONObject toGeoJsonFeature()
	{
		JSONObject oFeature = new JSONObject(); // Feature object
		oFeature.put("type", "Feature");
		JSONObject oProps = new JSONObject(); // properties object
		oProps.put("loaded", m_nLoaded);
		oProps.put("networkid", m_sNetworkId);
		oProps.put("label", m_sLabel);
		oProps.put("segments", m_oSegmentIds.size());
		oProps.put("filter", m_sFilter);
		oProps.put("options", m_sOptions);
		oProps.put("states", m_sStates);
		oProps.put("finalized", m_bFinalized);
		oFeature.put("properties", oProps);
		
		JSONObject oGeo = new JSONObject(); // geometry object
		oGeo.put("type", "Polygon");
		JSONArray oCoords = new JSONArray();
		JSONArray oRing = new JSONArray();
		
		Iterator<int[]> oIt = Arrays.iterator(m_nGeometry, new int[2], 5, 2); // start at index 5 to skip insertion point and bounding box
		while (oIt.hasNext())
		{
			int[] nPt = oIt.next();
			oRing.put(new double[]{GeoUtil.fromIntDeg(nPt[0]), GeoUtil.fromIntDeg(nPt[1])});
		}
		oCoords.put(oRing);
		oGeo.put("coordinates", oCoords);
		
		oFeature.put("geometry", oGeo);
		
		return oFeature;
	}
	
	
	/**
	 * Gets a new int array that contains the bounding box of the polygon
	 * 
	 * @return a new array with format [min lon, min lat, max lon, max lat]
	 */
	public int[] getBoundingBox()
	{
		return new int[]{m_nGeometry[1], m_nGeometry[2], m_nGeometry[3], m_nGeometry[4]};
	}
	
	
	/**
	 * Gets an Iterator for the points of the polygon. Wrapper for 
	 * {@link imrcp.system.Arrays#iterator(int[], int[], int, int)}
	 * 
	 * @return Iterator for the points of the polygon
	 */
	public Iterator<int[]> getPointIterator()
	{
		return Arrays.iterator(m_nGeometry, new int[2], 5, 2); // start at index 5 to skip insertion point and bounding box
	}
	
	
	/**
	 * Returns the number of coordinates (x,y pairs times 2) of the polygon.
	 * 
	 * @return The number of coordinates of the polygon
	 */
	public int getCoordinateCount()
	{
		return Arrays.size(m_nGeometry) - 5; // subtract 5 because of insertion point and bounding box at the beginning of the array
	}
	
	
	/**
	 * Wrapper for {@link GeoUtil#obsInside(java.awt.geom.Area, imrcp.store.Obs)}
	 * passing {@link #m_oArea} and the given Obs
	 * 
	 * @param oObs Obs to test if it is inside the Area defining the polygon
	 * @return true if the Obs is inside the Area, otherwise false
	 */
	public boolean obsInside(Obs oObs)
	{
		return GeoUtil.obsInside(m_oArea, oObs);
	}
	
	
	/**
	 * Determines if the given longitude/latitude coordinates are inside the
	 * Network polygon. Wrapper for {@link GeoUtil#isInside(int, int, int, int, int, int, int)}
	 * and {@link GeoUtil#isInsidePolygon(int[], double, double, int)}
	 * 
	 * @param nLon longitude in decimal degrees scaled to 7 decimal places
	 * @param nLat latitude in decimal degrees scaled to 7 decimal places
	 * @return true if the point is inside the Network polygon, otherwise false
	 */
	public boolean pointInside(int nLon, int nLat)
	{
		return GeoUtil.isInside(nLon, nLat, m_nGeometry[4], m_nGeometry[3], m_nGeometry[2], m_nGeometry[1], 0) &&
			GeoUtil.isInsidePolygon(m_nGeometry, nLon, nLat, 5);
	}
	
	
	/**
	 * Determines if the given roadway segment is a part of and inside the
	 * Network.
	 * @param oWay roadway segment to test
	 * @return true if the OsmWay's Id is in {@link #m_oSegmentIds} and at least
	 * one of its Nodes is inside the Network polygon, otherwise false
	 */
	public boolean wayInside(OsmWay oWay)
	{
		if (Collections.binarySearch(m_oSegmentIds, oWay.m_oId, Id.COMPARATOR) >= 0 && GeoUtil.boundingBoxesIntersect(oWay.m_nMinLon, oWay.m_nMinLat, oWay.m_nMaxLon, oWay.m_nMaxLat, m_nGeometry[1], m_nGeometry[2], m_nGeometry[3], m_nGeometry[4]))
		{
			for (OsmNode oNode : oWay.m_oNodes)
			{
				if (pointInside(oNode.m_nLon, oNode.m_nLat))
					return true;
			}
		}	
		return false;
	}
	
	
	/**
	 * Determines if the given Id is included in the Network. Any Id that does
	 * not represent a roadway segment is by default included.
	 * 
	 * @param oId Id to test
	 * @return true if the Id does not represent a roadway segment or if the Id
	 * represents a roadway segment and is in {@link #m_oSegmentIds}, otherwise
	 * false
	 */
	public boolean includeId(Id oId)
	{
		if (Id.isSegment(oId))
		{
			return Collections.binarySearch(m_oSegmentIds, oId, Id.COMPARATOR) >= 0;
		}
		
		return true;
	}
	
	
	/**
	 * Creates a new Area object from the Network polygon's geometry and sets
	 * {@link #m_oArea}'s reference to that Area
	 */
	private final void setArea()
	{
		Path2D.Double oPath = new Path2D.Double();
		Iterator<int[]> oIt = getPointIterator();
		if (oIt.hasNext())
		{
			int[] nPt = oIt.next();
			oPath.moveTo(nPt[0], nPt[1]);
		}
		while (oIt.hasNext())
		{
			int[] nPt = oIt.next();
			oPath.lineTo(nPt[0], nPt[1]);
		}
		oPath.closePath();
		m_oArea = new Area(oPath);
	}
	
	
	/**
	 * Compares Network objects by network id
	 */
	@Override
	public int compareTo(Network o)
	{
		return m_sNetworkId.compareTo(o.m_sNetworkId);
	}
}
