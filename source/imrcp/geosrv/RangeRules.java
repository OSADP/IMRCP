package imrcp.geosrv;

import imrcp.system.Config;
import imrcp.system.ObsType;
import imrcp.system.Units;

/**
 * Class used to bucket ranges of values of a specific observation type to a 
 * single value to aid in presentation and grouping similar observations.
 * @author Federal Highway Administration
 */
public class RangeRules
{
	/**
	 * Double value that corresponds to an invalid numerical value
	 */
	public double m_dNaNMapping;

	
	/**
	 * Array that stores the ranges in pairs [min1, max1, min2, max2,... minn, maxn]
	 */
	public double[] m_dRanges;

	
	/**
	 * Array that stores the ranges that should be ignored or deleted in pairs
	 * [min1, max1, min2, max2,... minn, maxn]
	 */
	public double[] m_dDeleteRanges;
	
	
	public String m_sUnits;
	
	public int m_nObsType;

	
	/**
	 * Wrapper for {@link #RangeRules(int)}. It converts the given observation 
	 * type to its integer representation.
	 * @param sObsType up to 6 alphanumeric characters representing an observation
	 * type
	 */
	public RangeRules(String sObsType)
	{
		this(Integer.valueOf(sObsType, 36));
	}
	
	
	/**
	 * Constructs a RangeRules object for the given observation type by reading
	 * values from the Configuration component.
	 * @param nObsType IMRCP observation type
	 */
	public RangeRules(int nObsType)
	{
		m_nObsType = nObsType;
		Config oConfig = Config.getInstance();
		String sConfigName = "rangerules_" + ObsType.getName(nObsType);
		m_dNaNMapping = Double.parseDouble(oConfig.getString(getClass().getName(), sConfigName, "nan", "-9999"));
		String[] sRanges = oConfig.getStringArray(getClass().getName(), sConfigName, "ranges" , null);
		String[] sDelete = oConfig.getStringArray(getClass().getName(), sConfigName, "delete", null);
		
		m_dRanges = new double[sRanges.length];
		for (int i = 0; i < sRanges.length; i++)
			m_dRanges[i] = Double.parseDouble(sRanges[i]);

		m_dDeleteRanges = new double[sDelete.length];
		for (int i = 0; i < sDelete.length; i++)
			m_dDeleteRanges[i] = Double.parseDouble(sDelete[i]);
		
		m_sUnits = Units.getInstance().getSourceUnits(nObsType, 0);
		if (m_sUnits == null)
			m_sUnits = "";
	}

	
	/**
	 * Determines if the given group value should be deleted/ignored based on the
	 * configured ranges.
	 * @param dGroupVal group value generated by {@link #groupValue(double)}
	 * @return true if the value if equal to the nan mapping, is {@code Double.NaN},
	 * or within one of the delete ranges, otherwise false.
	 */
	public boolean shouldDelete(double dGroupVal)
	{
		if (dGroupVal == m_dNaNMapping || Double.isNaN(dGroupVal)) // check for NaN
			return true;
		for (int i = 0; i < m_dDeleteRanges.length; i += 2) // check each range
		{
			if (dGroupVal >= m_dDeleteRanges[i] && dGroupVal < m_dDeleteRanges[i + 1])
				return true;
		}
		return false;
	}

	
	/**
	 * Gets the group/bucket value for the given value.
	 * @param dVal value to group
	 * @return The lower value of the range/group the value falls in or the nan
	 * mapping if the given value is {@code Double.NaN} or not within one of the
	 * configured ranges.
	 */
	public double groupValue(double dVal, String sUnits)
	{
		if (Double.isNaN(dVal))
			return m_dNaNMapping;
		if (sUnits != null && sUnits.compareTo(m_sUnits) != 0)
		{
			dVal = Units.getInstance().convert(sUnits, m_sUnits, dVal);
		}
		for (int i = 0; i < m_dRanges.length; i += 2)
		{
			if (dVal >= m_dRanges[i] && dVal < m_dRanges[i + 1])
				return m_dRanges[i];
		}
		return m_dNaNMapping;
	}
}
