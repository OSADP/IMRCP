/* 
 * Copyright 2017 Federal Highway Administration.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package imrcp.store;

import imrcp.system.Directory;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.sql.ResultSet;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.GregorianCalendar;

/**
 * The Store for Alerts that are generated by the Imrcp system
 */
public class AlertsStore extends CsvStore
{
	/**
	 * Header for obs file
	 */
	private String m_sHEADER = "ObsType,Source,ObjId,ObsTime1,ObsTime2,TimeRecv,Lat1,Lon1,Lat2,Lon2,Elev,Value,Conf,Cleared\n";

	/**
	 * Absolute path of the recovery file
	 */
	private String m_sRecoverFile;


	/**
	 * Loads the most recent Alert file into memory
	 *
	 * @return always returns true
	 * @throws Exception
	 */
	@Override
	public boolean start() throws Exception
	{
		File oFile = new File(m_sRecoverFile);
		if (oFile.exists())
		{
			loadFileToDeque(m_sRecoverFile);
			oFile.delete();
		}

		return true;
	}


	/**
	 * Resets the values of any configurable variable
	 */
	@Override
	public void reset()
	{
		m_nFileFrequency = m_oConfig.getInt("freq", 86400000);
		m_nDelay = m_oConfig.getInt("delay", 0);
		m_nRange = m_oConfig.getInt("range", 86400000);
		m_nLimit = m_oConfig.getInt("limit", 1);
		m_lKeepTime = Long.parseLong(m_oConfig.getString("keeptime", "86400000"));
		m_oFileFormat = new SimpleDateFormat(m_oConfig.getString("dest", ""));
		m_oFileFormat.setTimeZone(Directory.m_oUTC);
		m_nLruLimit = m_oConfig.getInt("lrulim", 53);
		m_sRecoverFile = m_oConfig.getString("recover", "");
	}


	/**
	 * Processes Notifications sent from other blocks
	 *
	 * @param oNotification the Notification from another block
	 */
	@Override
	public void process(Notification oNotification)
	{
		if (oNotification.m_sMessage.compareTo("file download") == 0)
		{
			String[] sFiles = oNotification.m_sResource.split(",");
			boolean bNewFile = false;
			for (String sFile : sFiles)
			{
				if (loadFileToDeque(sFile))
					bNewFile = true;
			}
			if (bNewFile)
				for (int nSubscriber : m_oSubscribers) // notify subscribers that there is new alerts data
					notify(this, nSubscriber, "new data", "");
		}
	}


	/**
	 * Always return the first file in the current files cache because there
	 * should only be one FileWrapper in there that contains the current Alerts
	 * or none.
	 *
	 * @param lTimestamp Timestamp of the query
	 * @param lRefTime Reference time of the query
	 * @return The FileWrapper that contains the current Alerts or null if the
	 * file has not been created yet
	 */
	@Override
	public synchronized FileWrapper getFileFromDeque(long lTimestamp, long lRefTime)
	{
		return m_oCurrentFiles.peekFirst();
	}


	/**
	 * Loads the given file into the current files cache
	 *
	 * @param sFile Path of the file to load
	 * @return true if the file is successfully loaded into memory
	 */
	@Override
	public boolean loadFileToDeque(String sFile)
	{
		try
		{
			m_oLogger.info("Loading " + sFile + " into memory: Deque");
			long lClearedTime = System.currentTimeMillis();
			lClearedTime = (lClearedTime / 60000) * 60000; // floor to nearest minute
			File oFile = new File(sFile);
			if (!oFile.exists())
				return false;
			AlertsCsv oWrapper = (AlertsCsv) getNewFileWrapper();
			oWrapper.load(0, Long.MAX_VALUE, sFile);
			AlertsCsv oRemove = null;
			synchronized (this)
			{
				oRemove = (AlertsCsv) m_oCurrentFiles.pollLast();
				m_oCurrentFiles.push(oWrapper);
			}
			if (oRemove != null)
			{
				int nIndex = oRemove.m_oObs.size();
				Calendar oStart = new GregorianCalendar(Directory.m_oUTC);
				Calendar oEnd = new GregorianCalendar(Directory.m_oUTC);

				while (nIndex-- > 0) // for each obs in the FileWrapper being removed
				{
					AlertObs oCurrent = (AlertObs) oRemove.m_oObs.get(nIndex);
					oCurrent.m_lClearedTime = lClearedTime;
					oStart.setTimeInMillis(oCurrent.m_lObsTime1);
					oEnd.setTimeInMillis(oCurrent.m_lObsTime2);
					oStart.add(Calendar.DAY_OF_YEAR, -1);
					do // write the obs to each file that it is valid for
					{
						oStart.add(Calendar.DAY_OF_YEAR, 1);
						oFile = new File(m_oFileFormat.format(oStart.getTime()));
						String sDir = oFile.getAbsolutePath().substring(0, oFile.getAbsolutePath().lastIndexOf("/"));
						new File(sDir).mkdirs();
						try (BufferedWriter oOut = new BufferedWriter(new FileWriter(oFile, true)))
						{
							if (oFile.length() == 0) // write header for new file
								oOut.write(m_sHEADER);
							oCurrent.writeCsv(oOut);
						}
					} while (oStart.get(Calendar.DAY_OF_YEAR) != oEnd.get(Calendar.DAY_OF_YEAR));
					oRemove.m_oObs.remove(nIndex);
				}

				oRemove.cleanup();
				String sFilename = m_oFileFormat.format(lClearedTime);
				Calendar oCal = new GregorianCalendar(Directory.m_oUTC);
				oCal.setTime(m_oFileFormat.parse(sFilename));
				loadFileToMemory(sFilename, true, oCal); // load the file for the cleared time into the lru to ensure the obs just removed from the current files cache are still available
			}
			return true;
		}
		catch (Exception oException)
		{
			m_oLogger.error(oException, oException);
			return false;
		}
	}


	/**
	 * Called when the block's service is stopped. Writes the current
	 * observations to a recover file to be loaded upon the block's next startup
	 *
	 * @return always true
	 * @throws Exception
	 */
	@Override
	public boolean stop() throws Exception
	{
		try (BufferedWriter oOut = new BufferedWriter(new FileWriter(m_sRecoverFile)))
		{
			oOut.write(m_sHEADER);
			ArrayList<Obs> oAlerts = ((AlertsCsv) m_oCurrentFiles.getFirst()).m_oObs;
			for (Obs oAlert : oAlerts)
				oAlert.writeCsv(oOut);
		}
		return true;
	}


	/**
	 * Fills the ImrcpResultSet with Obs that match the query
	 *
	 * @param oReturn ImrcpResultSet that will be filled with obs
	 * @param nType obstype id
	 * @param lStartTime start time of the query in milliseconds
	 * @param lEndTime end time of the query in milliseconds
	 * @param nStartLat lower bound of latitude (int scaled to 7 decimal places)
	 * @param nEndLat upper bound of latitude (int scaled to 7 decimals places)
	 * @param nStartLon lower bound of longitude (int scaled to 7 decimal
	 * places)
	 * @param nEndLon upper bound of longitude (int scaled to 7 decimal places)
	 * @param lRefTime reference time
	 */
	@Override
	public void getData(ImrcpResultSet oReturn, int nType, long lStartTime, long lEndTime,
	   int nStartLat, int nEndLat, int nStartLon, int nEndLon, long lRefTime)
	{
		long lObsTime = lStartTime;
		AlertsCsv oFile = (AlertsCsv) getFileFromDeque(lObsTime, lRefTime);
		if (oFile != null)
			getDataFromFile(oReturn, nType, lStartTime, lEndTime, nStartLat, nEndLat, nStartLon, nEndLon, lRefTime, oFile);
		while (lObsTime < lEndTime)
		{
			oFile = null;
			if (loadFilesToLru(lObsTime, lRefTime)) // load all files that could match the requested time
				oFile = (AlertsCsv) getFileFromLru(lObsTime, lRefTime); // get the most recent file
			if (oFile != null)
				getDataFromFile(oReturn, nType, lStartTime, lEndTime, nStartLat, nEndLat, nStartLon, nEndLon, lRefTime, oFile);
			lObsTime += m_nFileFrequency;
		}
	}


	/**
	 * Fills the ImrcpResultSet with Obs from the given csv file that match the
	 * query.
	 *
	 * @param oReturn
	 * @param nType
	 * @param lStartTime
	 * @param lEndTime
	 * @param nStartLat
	 * @param nEndLat
	 * @param nStartLon
	 * @param nEndLon
	 * @param lRefTime
	 * @param oFile
	 */
	@Override
	public void getDataFromFile(ImrcpResultSet oReturn, int nType, long lStartTime, long lEndTime,
	   int nStartLat, int nEndLat, int nStartLon, int nEndLon, long lRefTime, CsvWrapper oFile)
	{
		synchronized (oFile)
		{
			oFile.m_lLastUsed = System.currentTimeMillis();
			ArrayList<Obs> oObsList = oFile.m_oObs;
			if (oFile.m_oObs.isEmpty())
				return;

			for (int i = 0; i < oObsList.size(); i++)
			{
				AlertObs oObs = (AlertObs) oObsList.get(i);
				if ((oObs.m_lTimeRecv <= lRefTime || oObs.m_lTimeRecv > oObs.m_lObsTime1) && (oObs.m_lClearedTime == Long.MIN_VALUE || oObs.m_lClearedTime > lRefTime) && oObs.matches(nType, lStartTime, lEndTime, nStartLat, nEndLat, nStartLon, nEndLon))
				{
					int nIndex = Collections.binarySearch(oReturn, oObs, Obs.g_oCompByTimeTypeContribLatLon);
					if (nIndex < 0)
						oReturn.add(~nIndex, oObs);
					else
						oReturn.set(nIndex, oObs);
				}
			}
		}
	}


	/**
	 * Returns all of the alerts that are in the current files cache
	 *
	 * @return a ResultSet with 0 or more alerts in it
	 */
	public ResultSet getCurrentAlerts()
	{
		ImrcpResultSet oReturn = new ImrcpObsResultSet();
		AlertsCsv oCsv = (AlertsCsv) m_oCurrentFiles.peekFirst();
		if (oCsv != null)
			oReturn.addAll(oCsv.m_oObs);

		return oReturn;
	}


	/**
	 * Returns a new instance of CsvWrapper, since this is a CsvStore
	 *
	 * @return new CsvWrapper
	 */
	@Override
	protected FileWrapper getNewFileWrapper()
	{
		return new AlertsCsv();
	}
}
